---
title: 智能侧边栏总结
tags: 智能侧边栏,Android开发
grammar_cjkRuby: true
---


[TOC]

# 功能简介

包括智能侧边栏和游戏侧边栏两种模式，作用有点类似手机自带的下拉快捷控件中心，通过集成快捷工具、快捷开关和快捷应用，给用户提供方便快捷的功能操作。用户可以自由选择喜欢的快捷功能，将其添加到侧边栏（后续无特别说明，则侧边栏指智能侧边栏和游戏侧边栏）中，解决多应用间的快速切换以及内容传输，进一步提升效率。但展现形式以及功能侧重点有所不同：

1.竖屏下的侧边栏以一根极细的FloatBar吸附在屏幕边缘，用户可以在不影响当前应用的情况下，通过滑动FloatBar呼出侧边栏来选择快捷操作；而横屏下的FloatBar则完全隐藏，用户只需在屏幕凹槽处向内滑动即可呼出侧边栏。这样的设计可以极大地减少侧边栏对界面的遮挡，让用户在使用快捷功能的过程中拥有更好的体验。

2.目前侧边栏集成的主要功能有：

- 文件台：快速分享图片
- 速记：快速记录文字、语音、图片
- 截屏
- 录屏
- 屏蔽横幅
- 屏蔽通知
- 游戏资讯：提供游戏资讯
- 桌面应用：可放置常用的桌面应用，作为应用启动入口

# 框架介绍

下图是侧边栏的类图，主要包括：

- UI类
  - EdgePanelUI：继承了SystemUI，是侧边栏的启动入口，其它模块和侧边栏的交互会通过该类来触发，比如呼出编辑栏，退出侧边栏等。
  - EdgePanelLayer：这是一个继承了RelativeLayout的抽象类，作为一个全屏的浮动View添加，Title为"ColorOSEdgePanel"，层级为17，低于状态栏。子类有SmartEdgePanelLayer和GameEdgePanelLayer，EdgePanelView和EdgePanelEditView都作为子view添加到EdgePanelLayer。
  - EdgeFloatBar：自定义浮动View，和EdgePanelLayer相同层级，Title为"ColorOSEdgeFloatBar"，作为侧边栏的浮标。
  - EdgePanelView：继承LinearLayout，放置快捷功能的窗口。
  - EdgePanelEditView：继承RelativeLayout，作为编辑栏放置候选快捷功能的窗口。
  - EdgeTileCard：继承RelativeLayout，作为EdgePanelView的子View，共包含3个EdgeTileCard对象，分别放置快捷工具，快捷开关，快捷应用。
  - DraggableGridViewPager：自定义ViewGroup，类似于GridView，实现了翻页，点击Item，删除Item，拖动Item等功能。没有选择RecyclerView来实现的原因：RecyclerView设置横向布局里，子View的排列是从上到右，从左至右。这样在拖动和删除Item的时候，子View的移动顺序与预期不符。虽然有一些规避的方法，但处理起来比较复杂且不利于后期扩展。
  - EdgeTileView：继承FrameLayout，作为容纳快捷功能的窗口。
  - GameHungUpView：继承RelativeLayout，全屏的浮动View，Title为"ColorOSGameHangUp"，层级为55，高于状态栏，低于导航栏。作为启动游戏挂机功能的界面。

- 逻辑控制类
  - EdgePanelController：侧边栏的逻辑控制类，包括添加侧边栏、移除侧边栏、添加浮标、移除浮标、进入编辑栏、退出编辑栏等操作。
  - GameHungUpController：游戏挂机的逻辑控制类，包括启动游戏挂机，退出游戏挂机等操作。

- 数据工具类
  - EdgePanelDataUtil：负责侧边栏的数据处理
  - EdgePanelFileUtil：负责侧边栏的数据读取和存储

![](https://www.filepicker.io/api/file/4MR8zJomTn2NT9ltUIhK)

<br/>
下图是侧边栏界面的截图，可以通过截图和上面的类图进行对比，快速了解侧边栏的UI结构。

![](https://www.filepicker.io/api/file/Kll7Wp0LSTKPfd2Up4hm)



# 关键流程

## 智能侧边栏初始化
<center>智能侧边栏初始化时序图</center>
![](https://www.filepicker.io/api/file/8U239Q7mTAOLKawDmMNW)

## 呼出侧边栏
<center>呼出侧边栏时序图</center>
![](https://www.filepicker.io/api/file/mpzSQv3TSkWhFueKgGkp)

## 呼出编辑栏
<center>呼出编辑栏时序图</center>
![](https://www.filepicker.io/api/file/9eQh9owDQxitVjyhCibG)

## 游戏挂机功能
### 功能简介
游戏挂机功能使手机进入一个挂机状态，具体表现为屏幕亮度降低，一个半透明的遮罩覆盖在应用界面上，通过文字和动画提示用户需要滑动解除挂机状态。

游戏挂机功能可以让用户在不需要频繁操作手机时，降低功耗，减少应用干扰，但仍然使应用保持运行状态，并且可以快速解除挂机状态回到应用。

### 功能实现
游戏挂机的实现原理是：通过游戏侧边栏中的快捷工具入口，添加一个全屏的游戏挂机View。游戏挂机View的参数如下：
```
DisplayMetrics displayMetrics = getDisplayMetrics(context);
WindowManager.LayoutParams windowParams = new WindowManager.LayoutParams();
int type = ColorWindowManager.LayoutParams.TYPE_SYSTEM_GAME_HUNG_UP_VIEW;
windowParams.type = type;
windowParams.format = PixelFormat.RGBA_8888;
windowParams.flags = WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR
		| WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
		| WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS
		| WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
		| FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS
		| WindowManager.LayoutParams.FLAG_FULLSCREEN;
windowParams.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
windowParams.format = PixelFormat.TRANSLUCENT;
windowParams.gravity = Gravity.CENTER;
int size = (displayMetrics.heightPixels > displayMetrics.widthPixels) ? displayMetrics.heightPixels : displayMetrics.widthPixels;
windowParams.width = size;
windowParams.height = size;
windowParams.setTitle("ColorOSGameHangUp");
```

- TYPE_SYSTEM_GAME_HUNG_UP_VIEW： 自定义的一种type=2313，层级为55，高于状态栏低于导航栏。
- FLAG_KEEP_SCREEN_ON：保持屏幕长亮的flag。
- FLAG_LAYOUT_NO_LIMITS：界面可以扩展到屏幕外。
- FLAG_FULLSCREEN：全屏

打印游戏挂机窗口属性：
```
mFrame=[-600,0][1680,2280] last=[-600,0][1680,2280]
Frames: containing=[0,0][1080,2280] parent=[0,0][1080,2280]
	display=[-10000,-10000][10000,10000] overscan=[-10000,-10000][10000,10000]
	content=[-600,0][1680,2280] visible=[-600,0][1680,2280]
	decor=[0,0][1080,2280]
	outset=[-10000,-10000][10000,10000]
```

<center>启动游戏挂机时序图</center>

![enter description here](./images/开启游戏挂机时序图.png)

## 浮标
### 浮标位置
- 竖屏：可以长按浮标进行拖动，浮标最后会吸附到屏幕边缘位置。
  - LTR布局，默认在屏幕右边缘[screenWidth-mWidth/2, 200dp]
  - RTL布局，默认在屏幕左边缘[-mWidth/2, 200dp]
- 横屏：横屏不显示浮标

### 浮标的onTouchEvent
```
mPressRunnable = new Runnable() {
    @Override
    public void run() {
        if (mPopEnable) {
            mPopEnable = false;
            if (!mDragEnable) {
                swipeOut();
            } else {
                Log.d(TAG, "swipeOut() dragEnable true");
            }
        }
    }
};
mDragRunnable = new Runnable() {

    @Override
    public void run() {
        if (!mHasOut) {
            mAlpha = COLOR_ARGB_ALPHA_HIGH;
            mStrokeAlpha = COLOR_STROKE_ARGB_ALPHA;
            mDragEnable = true;
            dragPressScaleAnim();
        }
    }
};

mIdleRunnable = new Runnable() {
    @Override
    public void run() {
        if (!mHasOut) {
            animIdle();
        }
    }
};

public boolean onTouchEvent(MotionEvent event) {
    if (mHasOut) {
        // FloatBar已经退出，不响应Touch事件。
        return super.onTouchEvent(event);
    }
    int action = event.getAction();
    float curX = event.getRawX();
    float curY = event.getRawY();

    mCurX = curX;
    mCurY = curY;
    switch (action) {
        case MotionEvent.ACTION_DOWN: {
            mDownX = curX;
            mDownY = curY;
            mOffsetY = (int) curY - mWindowParams.y;
            ...
            mPopEnable = true;
            
            // 注意，这两个Runnable都是延时触发的。SWIPE_POP_SHOW_TIME=300L，DRAG_ENABLE_DELAY=150L。
            postDelayed(mPressRunnable, SWIPE_POP_SHOW_TIME);
            ...

            postDelayed(mDragRunnable, DRAG_ENABLE_DELAY);

            break;
        }
        case MotionEvent.ACTION_MOVE:
            // 如果手指有移动，则取消mDragRunnable，mDragEnable是在mDragRunnable中置为true
            if (curX != mDownX) {
                removeCallbacks(mDragRunnable);
            }
            
            if (mDragEnable) {
                // 超过150ms没有移动手指，mDragEnable->true，进入拖动操作
                // (1)拖动操作
                if (mOpState == STATE_DRAG_DAMP) {
                    int midX = mScreenSize.x / 2;
                    if ((((mDampStartLayX + mWidth / 2) < midX) && (curX < midX))) {
                        // FloatBar在左侧拖动
                        mWindowParams.x = getLeftDampX(curX);
                        mWindowParams.y = getDampY(curY);
                        mWindowManager.updateViewLayout(this, mWindowParams);
                    } else if (((mDampStartLayX + mWidth / 2) > midX) && (curX > midX)) {
                        // FloatBar在右侧拖动
                        mWindowParams.x = getRightDampX(curX);
                        mWindowParams.y = getDampY(curY);
                        mWindowManager.updateViewLayout(this, mWindowParams);
                    } else {
                        // 从屏幕一侧拖动到另一侧
                        dragThroughAnim();
                    }
                }
            } else if (mPopEnable) {
                // 300ms内移动手指，mDragEnable->false，mPopEnable=true，尝试呼出侧边栏。
                // 300ms后触发mDragRunnable，mPopEnable->false
                // (2)呼出侧边栏操作
                swipeOut();
                ...
            }
            break;
        case MotionEvent.ACTION_UP:
            ...
        case MotionEvent.ACTION_CANCEL:
            removeCallbacks(mPressRunnable);
            removeCallbacks(mDragRunnable);

            if (mDragEnable) {
                // 重置mDragEnable状态
                mDragEnable = false;
                ...
            } else if (mPopEnable) {
                // 必须在300L时间内滑动结束，否则mPopEnable->false。
                // 一般300L时间内无法滑动足够距离，所以不会从这里呼出侧边栏
                touchUpOut(event);
            }
            ...
            // (3)点击操作
            touchUpAnim();
            postDelayed(mIdleRunnable, IDLE_ANIM_DELAY);
            ...
            break;
        default:
            break;
    }
    return super.onTouchEvent(event);
}
```
- (1)拖动操作
调整浮标位置:updateViewLayout();
- (2)滑动操作
呼出侧边栏:swipeOut();
- (3)快速点击浮标
scale和translation动画:touchUpAnim(); 




## 侧边栏加载快捷功能流程
以智能侧边栏为例，游戏侧边栏类似。
```
// Step1. 读取Tile数据保存到host
[->SmartEdgePanelData.java]
SmartEdgePanelData
  // 读取Tile数据并保存到mSetTiles中。
  mEdgePanelFileUtil.getTileDescriptionsFromFile
  // 初始化三个EdgeTileCard的参数
  getFirstCardParams
  getSecondCardParams
  getThirdCardParams
    // 第三个Card比较特殊，首次只会加载5个。
    if (首次加载) {
      host.refreshTiles(descs, 5);
    } else {
      // 根据descs创建EdgeTile，并更新Tile的状态。
      host.refreshTiles(descs);
    }

// Step2. 初始化EdgeTileCard   
[->EdgeTileCard.java]
initCardView
  mEdgeDragGridPager.setHost
    [->EdgeDragGridPager.java]
    setHost
      // 遍历host中的数据，并addView添加到EdgeDrageGridPager
      addView
```
备注：
- 如果是侧边栏加载的快捷功能(Tile）不对，可以查看SmartEdgePanelData.java和EdgePanelFileUtil的log，确认读取数据的流程是否有问题。
- 如果是侧边栏加载的快捷功能(Tile)界面显示位置问题，则需要检查DraggableGridViewPager的onLyaout方法。

## 强制退出侧边栏的场景
- 下拉状态栏或点击横幅
[->StatusBarWindowView.java]->dispatchTouchEvent->EdgePanelUI.removeEdgePanelView
- 点击快捷功能（屏蔽横幅，拒接来电除外）
[->EdgeTile.java]->handleClick->EdgePanelUI.removeEdgePanelView
- 操作导航手势
[->GestureTransitionViewController.java]->onSwipeSuccess->EdgePanelUI.removeEdgePanelView
- 点击全屏横幅
[->FullScreenBanner.java]->onInterceptTouchEvent->EdgePanelUI.removeEdgePanelView
- 首次开机前3次进入横屏会自动呼出侧边栏，3S后退出
[->EdgePanel.java]->autoDisplayEPGuide->removeEdgePanel
- 进入儿童模式
[->EdgePanel.java]->onChildrenModeChanged->removeEdgePanelView
- 进入分屏模式
[->EdgePanelUI.java]->toggleSplitScreen->removeEdgePanelView
- 开关切换、进入游戏空间应用
[->EdgePanel.java]->updateEdgePanel->onLocalStateChanged->removeEdgePanel
- Rotation变化
[->EdgePanel.java]->onRotationChanged->removeEdgePanel
- 进入小屏模式
[->EdgePanel.java]->registerSmallScreenReceiver->removeEdgePanel
- 进入来电界面，视频通话界面，锁卡界面等特殊界面
[->EdgePanelController.java]->topAppWindowChanged->removeEdgePanelView
- 按返回键
[->EdgePanelLayer.java]->init->popOut->removePanelView
- 点击非侧边栏区域
[->EdgePanelLayer.java]->onTouchEvent->removePanelView
- 点击/长按Home键/使用语音助手/息屏
[->EdgePanelLayer.java]->registerReceiver->removePanelView



## 侧边栏数据初始化和更新
![](https://www.filepicker.io/api/file/WQyW8YTc6F9pMNlaSXAp)


## 添加埋点
主要有两种，分别是：

- 每次操作都定时上报，使用的类：OppoStatisticHelper.java
示例：
```
public static void collectXXX(Context context, String action) {
	Map<String, String> eventMap = new HashMap<>();
	eventMap.put(KEY, action);
	onCommon(context, EVENT_ID, eventMap);
}
```
- 每天上报最后状态，使用的类：StaticDataStatReceiver.java
示例：
```
public static void collectXXX(Context context, String action) {
	Map<String, String> dataMap = new HashMap<>();
	dataMap.put(KEY, action);
	NearMeStatistics.onCommon(context, LOG_TAG, EVENT_ID, dataMap);
}
```

# 经验总结

- 开展项目前，应该首先定好项目框架和实现方案，避免盲目动手导致后面推翻重做。在实现需求和功能的时候，不仅要考虑眼前功能的实现，还要多思考代码的健壮性和拓展性，以及对其它模块的影响。尽量避免因为某一个问题的修改引发新的BUG。
- UI动画较多时，需要理清各个动画切换的逻辑。UI动画的实现虽然简单，但当多个View同时做动画且状态相关联时，就需要考虑更多的问题。比如呼出侧边栏时必须隐藏浮标，退出侧边栏时必须显示浮标，进入/退出编辑时，侧边栏的动画等。最初，由于这些动画之间的状态没有控制好，导致经常出现侧边栏无法呼出，浮标消失，侧边栏界面异常等问题。最后重新做了一次重构，将各个动画之间的状态进行了梳理，保证了即使在快速操作时各界面的正常切换。
- RecyclerView相对于GridView使用更方便，拓展性更强。编辑栏由于快捷开关，浮窗应用，普通应用三种类型的存在，起初是直接利用GridView+ScrollView来实现的，界面显示和功能都没有问题，但在首次进入编辑栏时会有明显的卡顿。当时也没有太在意，准备留到后期进行优化。
后期优化的时候，发现了比较明显的几个问题：
1. 三种类型的元素，使用了三个GridView对象，数据处理不方便。
2. GridView+ScrollView的组合，为了解决显示不全的问题，需要重写onMeasure，并将测量高度设为了无限高。这导致首次加载的应用缩略图非常多，尤其在用户手机上的应用上百个的时候，非常消耗资源。
3. 通过包名来获取应用的缩略图和名字，虽然单个消耗的时间只在几ms之内，但按照当前的设计方案，一次性的加载几百个，那么消耗的时间就非常可观，给用户带来的体验就非常不好。
针对上述几个问题，最后团队讨论采取了如下措施：
1. 采用RecyclerView来替代GridView，并将几种不同的GridView类型合并到一个RecyclerView中，从而方便了数据处理。
2. 采用RecyclerView后，分页加载大大减少了资源和时间的消耗。
3. 将所有桌面应用的包名等数据在开机启动侧边栏时，在后台保存起来，并监听应用的安装和删除，实时更新数据。这样在启动编辑栏时便只需要从保存的数据中获取，而不需要通过系统接口去获取了。
- 用户数据的保存和更新需要考虑前后兼容且不影响用户使用。最初在做预置快捷功能数据更新时，并没有考虑周全，导致很多用户互动版本升级后，疑惑地发现侧边栏多了很多并非自己主动添加的快捷应用，这其实是升级策略有误导致。经过过多次讨论和修改，最终才定下一个比较完善的升级方案。
